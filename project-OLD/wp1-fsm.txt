`include "Sysbus.defs"

module top
#(
  MAX_TIMEOUT = 1000,
  ID_WIDTH = 13,
  ADDR_WIDTH = 64,
  DATA_WIDTH = 64,
  STRB_WIDTH = DATA_WIDTH/8
)
(
  input  clk,
         reset,
         hz32768timer,

  // 64-bit addresses of the program entry point and initial stack pointer
  input  [63:0] entry,
  input  [63:0] stackptr,
  input  [63:0] satp,

  // interface to connect to the bus
  output  wire [ID_WIDTH-1:0]    m_axi_awid,
  output  wire [ADDR_WIDTH-1:0]  m_axi_awaddr,
  output  wire [7:0]             m_axi_awlen,
  output  wire [2:0]             m_axi_awsize,
  output  wire [1:0]             m_axi_awburst,
  output  wire                   m_axi_awlock,
  output  wire [3:0]             m_axi_awcache,
  output  wire [2:0]             m_axi_awprot,
  output  wire                   m_axi_awvalid,
  input   wire                   m_axi_awready,
  output  wire [DATA_WIDTH-1:0]  m_axi_wdata,
  output  wire [STRB_WIDTH-1:0]  m_axi_wstrb,
  output  wire                   m_axi_wlast,
  output  wire                   m_axi_wvalid,
  input   wire                   m_axi_wready,
  input   wire [ID_WIDTH-1:0]    m_axi_bid,
  input   wire [1:0]             m_axi_bresp,
  input   wire                   m_axi_bvalid,
  output  wire                   m_axi_bready,
  output  wire [ID_WIDTH-1:0]    m_axi_arid,
  output  wire [ADDR_WIDTH-1:0]  m_axi_araddr,
  output  wire [7:0]             m_axi_arlen,
  output  wire [2:0]             m_axi_arsize,
  output  wire [1:0]             m_axi_arburst,
  output  wire                   m_axi_arlock,
  output  wire [3:0]             m_axi_arcache,
  output  wire [2:0]             m_axi_arprot,
  output  wire                   m_axi_arvalid,
  input   wire                   m_axi_arready,
  input   wire [ID_WIDTH-1:0]    m_axi_rid,
  input   wire [DATA_WIDTH-1:0]  m_axi_rdata,
  input   wire [1:0]             m_axi_rresp,
  input   wire                   m_axi_rlast,
  input   wire                   m_axi_rvalid,
  output  wire                   m_axi_rready,
  input   wire                   m_axi_acvalid,
  output  wire                   m_axi_acready,
  input   wire [ADDR_WIDTH-1:0]  m_axi_acaddr,
  input   wire [3:0]             m_axi_acsnoop
);

logic [1:0] fsm_state;
localparam [2:0] IDLE = 3'b000, FETCH = 3'b001, DECODE = 3'b010, WAIT_FOR_DATA = 3'b011, HALT = 3'b100;  // Added WAIT_FOR_DATA
logic [63:0] pc;
// logic [DATA_WIDTH-1:0] instruction;  // Register to hold fetched instruction
reg [31:0] instr1, instr2;

// Extract fields from instruction
logic [6:0] opcode;
logic [4:0] rd;
logic [2:0] funct3;
logic [6:0] funct7;
logic [4:0] rs1, rs2;
string mnemonic;
logic [11:0] imm;
logic terminate_simulation = 0;
logic read_request_pending;
// logic decode_request_pending = 0;
logic [31:0] timeout_counter;

// Task to display the ABI name of a register given its number in binary
task display_reg_name(input [4:0] reg_num);
begin
    case (reg_num)
        5'b00000: $write("zero");  // x0
        5'b00001: $write("ra");    // x1 (Return Address)
        5'b00010: $write("sp");    // x2 (Stack Pointer)
        5'b00011: $write("gp");    // x3 (Global Pointer)
        5'b00100: $write("tp");    // x4 (Thread Pointer)
        5'b00101: $write("t0");    // x5 (Temporary Register 0)
        5'b00110: $write("t1");    // x6 (Temporary Register 1)
        5'b00111: $write("t2");    // x7 (Temporary Register 2)
        5'b01000: $write("s0");    // x8 (Saved Register 0 / Frame Pointer)
        5'b01001: $write("s1");    // x9 (Saved Register 1)
        5'b01010: $write("a0");   // x10 (Function Argument / Return Value 0)
        5'b01011: $write("a1");   // x11 (Function Argument / Return Value 1)
        5'b01100: $write("a2");   // x12 (Function Argument 2)
        5'b01101: $write("a3");   // x13 (Function Argument 3)
        5'b01110: $write("a4");   // x14 (Function Argument 4)
        5'b01111: $write("a5");   // x15 (Function Argument 5)
        5'b10000: $write("a6");   // x16 (Function Argument 6)
        5'b10001: $write("a7");   // x17 (Function Argument 7)
        5'b10010: $write("s2");   // x18 (Saved Register 2)
        5'b10011: $write("s3");   // x19 (Saved Register 3)
        5'b10100: $write("s4");   // x20 (Saved Register 4)
        5'b10101: $write("s5");   // x21 (Saved Register 5)
        5'b10110: $write("s6");   // x22 (Saved Register 6)
        5'b10111: $write("s7");   // x23 (Saved Register 7)
        5'b11000: $write("s8");   // x24 (Saved Register 8)
        5'b11001: $write("s9");   // x25 (Saved Register 9)
        5'b11010: $write("s10");  // x26 (Saved Register 10)
        5'b11011: $write("s11");  // x27 (Saved Register 11)
        5'b11100: $write("t3");   // x28 (Temporary Register 3)
        5'b11101: $write("t4");   // x29 (Temporary Register 4)
        5'b11110: $write("t5");   // x30 (Temporary Register 5)
        5'b11111: $write("t6");   // x31 (Temporary Register 6)
        default: $write("unknown ");     // Unknown register
    endcase
end
endtask

module ALU (
    input [63:0] operand1,     // First operand (from rs1 or immediate)
    input [63:0] operand2,     // Second operand (from rs2 or immediate)
    input [3:0] ALUop,         // ALU operation selector
    output reg [63:0] result,  // Result of the operation
    output zero                // Zero flag, for branch instructions
);
  
  // Zero flag is set when result is zero
  assign zero = (result == 0);
  
  always @(*) begin
    case (ALUop)
      4'b0000: result = operand1 + operand2; // ADD, ADDI
      4'b0001: result = operand1 - operand2; // SUB
      4'b0010: result = operand1 & operand2; // AND
      4'b0011: result = operand1 | operand2; // OR
      4'b0100: result = operand1 ^ operand2; // XOR
      4'b0101: result = operand1 << operand2[5:0]; // SLL (Shift Left Logical)
      4'b0110: result = operand1 >> operand2[5:0]; // SRL (Shift Right Logical)
      4'b0111: result = $signed(operand1) >>> operand2[5:0]; // SRA (Shift Right Arithmetic)
      default: result = 0; // Default
    endcase
  end
endmodule


    
task decode_and_display(
    input [31:0] instr,          // Instruction to decode
    input [6:0] opcode,          // Opcode field
    input [4:0] rd,              // Destination register field
    input [2:0] funct3,          // Function code (3 bits)
    input [6:0] funct7,          // Function code (7 bits)
    input [4:0] rs1,             // Source register 1 field
    input [4:0] rs2,             // Source register 2 field
    input [11:0] imm             // Immediate value
);
  begin
    // $display("\n[Decoding instruction] %h", instr);
    // $display("PART 1 || Opcode: %b, funct3: %b, funct7: %b, rd: %b, rs1: %b, rs2: %b, imm: %d", opcode, funct3, funct7, rd, rs1, rs2, $signed(imm));    
    
    case (opcode)
        7'b0010011: begin  // ADDI and related instructions
          if (rd == 5'b00000 && rs1 == 5'b00000 && imm == 12'b000000000000) begin  // Specific case for NOP
              $write("%h: nop", instr);
          end else if (rd == 5'd2 && rs1 == 5'd2) begin  // Specific case for stack pointer (sp)
              $write("%h: addi sp, sp, %0d", instr, $signed(imm));
          end else if (rs1 == 5'b00000) begin  // Special case for li (load immediate)
              $write("%h: li ", instr);
              display_reg_name(rd);
              $write(", %0d", $signed(imm));
          end else if (imm == 12'd0) begin  // Special case for mv (move)
              $write("%h: mv ", instr);
              display_reg_name(rd);
              $write(", ");
              display_reg_name(rs1);
          end else if (funct3 == 3'b001 && funct7 == 7'b0000000) begin  // SLLI (Shift Left Logical Immediate)
              $write("%h: slli ", instr);
              display_reg_name(rd);
              $write(", ");
              display_reg_name(rs1);
              $write(", %0d", instr[24:20]); // Shift amount
          end else begin  // General case for ADDI
              $write("%h: addi ", instr);
              display_reg_name(rd);
              $write(", ");
              display_reg_name(rs1);
              $write(", %0d", $signed(imm));  // General case
          end
      end


        7'b0110111: begin // LUI
            $write("%h: lui ", instr);
            display_reg_name(rd);
            $write(", 0x%x", imm);
        end

        7'b0010111: begin // AUIPC
            $write("%h: auipc ", instr);
            display_reg_name(rd);
            $write(", 0x%x", imm);
        end

        7'b0100011: begin // Store instructions: SW or SD
            case (funct3)
              3'b000: begin // SB (Store Byte)
                  $write("%h: sb ", instr);
                  display_reg_name(rs2);
                  $write(", %0d(", $signed({instr[31:25], instr[11:7]}));
                  display_reg_name(rs1);
                  $write(")");
              end
            
                3'b011: begin // SD (Store Double Word)
                    $write("%h: sd ", instr);
                    display_reg_name(rs2);
                    $write(", %0d(", $signed({instr[31:25], instr[11:7]}));
                    display_reg_name(rs1);
                    $write(")");
                end
                3'b010: begin // SW (Store Word)
                    $write("%h: sw ", instr);
                    display_reg_name(rs2);
                    $write(", %0d(", $signed({instr[31:25], instr[11:7]}));
                    display_reg_name(rs1);
                    $write(")");
                end
                default: $display("%h: UNKNOWN", instr);
            endcase
        end

        7'b0000011: begin  // Load instructions (LW, LD, etc.)
            case (funct3)
                3'b010: begin // LW
                    $write("%h: lw ", instr);
                    display_reg_name(rd);
                    $write(", %0d(", $signed(imm));
                    display_reg_name(rs1);
                    $write(")");
                end
                3'b011: begin // LD
                    $write("%h: ld ", instr);
                    display_reg_name(rd);
                    $write(", %0d(", $signed(imm));
                    display_reg_name(rs1);
                    $write(")");
                end
                3'b100: begin // LBU (Load Byte Unsigned)
                  $write("%h: lbu ", instr);
                  display_reg_name(rd);
                  $write(", %0d(", $signed(imm));
                  display_reg_name(rs1);
                  $write(")");
                  end
                default: $display("%h: UNKNOWN", instr);  // Unknown load instruction
            endcase
        end
        7'b1100111: begin  // JALR and RET
            if (funct3 == 3'b000 && rs1 == 5'b00001 && rd == 5'b00000) begin
                $display("%h: ret", instr); // Print 'ret' when rd = x0 and rs1 = x1
            end else if (rd == 5'b00001 && imm == 12'b0) begin
                // Special case for JALR with rd = ra (x1) and imm = 0: 'jalr rs1'
                $write("%h: jalr ", instr);
                display_reg_name(rs1);
            end else begin
                // General case
                $write("%h: jalr ", instr);
                display_reg_name(rd);
                $write(", ");
                display_reg_name(rs1);
                $write(", 0x%x", $signed(imm));
            end
        end
        7'b1101111: begin // JAL and J (Jump)
            if (rd == 5'b00000) begin  // Check if it is a 'j' instruction
                $write("%h: j ", instr);
                // Correct calculation of the immediate value
                $write("0x%x", $signed({instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}));
            end else begin
                $write("%h: jal ", instr);
                display_reg_name(rd);
                $write(", 0x%x", $signed({instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}));
            end
        end



        7'b1100011: begin // Branch instructions: BEQ, BEQZ, BNE, BNEZ, BLE, BLEZ, BGEZ, BGTZ, BLT, BLTZ
        case (funct3)
            3'b000: begin // BEQ or BEQZ
                if (rs2 == 5'b00000) begin
                    $write("%h: beqz ", instr);
                    display_reg_name(rs1);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: beq ", instr);
                    display_reg_name(rs1);
                    $write(", ");
                    display_reg_name(rs2);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end
            end
            3'b001: begin // BNE or BNEZ
                if (rs2 == 5'b00000) begin  // Special case for BNEZ
                    $write("%h: bnez ", instr);
                    display_reg_name(rs1);
                    $write(", 0x%x", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: bne ", instr);
                    display_reg_name(rs1);
                    $write(", ");
                    display_reg_name(rs2);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end
                end
            3'b101: begin // BGE or BGTZ
                if (rs2 == 5'b00000) begin // Special case for BGTZ
                    $write("%h: bgtz ", instr);
                    display_reg_name(rs1);
                    $write(", 0x%x", $unsigned({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: bge ", instr);
                    display_reg_name(rs1);
                    $write(", ");
                    display_reg_name(rs2);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end
            end
            3'b100: begin // BLT (Branch if Less Than) or BLTZ
                if (rs2 == 5'b00000) begin // Special case for BLTZ
                    $write("%h: bltz ", instr);
                    display_reg_name(rs1);
                    $write(", 0x%x", $unsigned({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: blt ", instr);
                    display_reg_name(rs1);
                    $write(", ");
                    display_reg_name(rs2);
                    // Correct offset calculation and display in hexadecimal
                    $write(", 0x%x", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end
            end

            3'b110: begin // BLE or BLEZ
                if (rs2 == 5'b00000) begin // Special case for BLEZ
                    $write("%h: blez ", instr);
                    display_reg_name(rs1);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: ble ", instr);
                    display_reg_name(rs1);
                    $write(", ");
                    display_reg_name(rs2);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end
            end
            3'b011: begin // BGEZ (Branch if Greater than or Equal to Zero)
                if (rs2 == 5'b00000) begin
                    $write("%h: bgez ", instr);
                    display_reg_name(rs1);
                    $write(", %0d", $signed({instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}));
                end else begin
                    $write("%h: UNKNOWN", instr); // Fallback for unknown instructions
                end
            end
            default: $display("%h: UNKNOWN", instr);
        endcase
    end

        7'b0110011: begin // ADD and SEQZ
            if (funct3 == 3'b000 && rs2 == 5'b00000) begin
                $write("%h: seqz ", instr);
                display_reg_name(rd);
                $write(", ");
                display_reg_name(rs1);
            end else begin
                $write("%h: add ", instr);
                display_reg_name(rd);
                $write(", ");
                display_reg_name(rs1);
                $write(", ");
                display_reg_name(rs2);
            end
        end
        7'b0011011: begin // RV64I instructions (e.g., ADDIW, SLLIW)
            case (funct3)
                3'b000: begin // ADDIW (Add Immediate Word)
                    $write("%h: addiw ", instr);
                    display_reg_name(rd);
                    $write(", ");
                    display_reg_name(rs1);
                    $write(", %0d", $signed(imm)); // Immediate for the addiw instruction
                end
                3'b001: begin // SLLIW (Shift Left Logical Immediate Word)
                    $write("%h: slliw ", instr);
                    display_reg_name(rd);
                    $write(", ");
                    display_reg_name(rs1);
                    $write(", %0d", instr[24:20]); // Immediate for shift amount
                end
                default: $display("%h: UNKNOWN", instr);  // Unknown instruction in RV64I with opcode 0011011
            endcase
        end

        7'b0111011: begin // RV64M instructions (e.g., ADDW, MULW, REMW, DIVW, etc.)
            case (funct3)
                3'b000: begin // ADDW (Add Word) or MULW (Multiply Word)
                    if (funct7 == 7'b0000000) begin
                        $write("%h: addw ", instr);
                        display_reg_name(rd);
                        $write(", ");
                        display_reg_name(rs1);
                        $write(", ");
                        display_reg_name(rs2);
                    end
                    else if (funct7 == 7'b0000001) begin // MULW (Multiply Word)
                        $write("%h: mulw ", instr);
                        display_reg_name(rd);
                        $write(", ");
                        display_reg_name(rs1);
                        $write(", ");
                        display_reg_name(rs2);
                    end
                    else begin
                        $display("%h: UNKNOWN", instr);  // Unknown instruction with funct7
                    end
                end
                3'b001: begin // SLLIW (Shift Left Logical Immediate Word)
                    if (funct7 == 7'b0000000) begin // SLLIW (Shift Left Logical Immediate Word)
                        $write("%h: slliw ", instr);
                        display_reg_name(rd);
                        $write(", ");
                        display_reg_name(rs1);
                        $write(", %0d", instr[24:20]); // Shift amount
                    end else begin
                        $display("%h: UNKNOWN", instr);  // Unknown instruction with funct7
                    end
                end
                3'b100: begin // DIVW (Divide Word)
                    if (funct7 == 7'b0000001) begin
                        $write("%h: divw ", instr);
                        display_reg_name(rd);
                        $write(", ");
                        display_reg_name(rs1);
                        $write(", ");
                        display_reg_name(rs2);
                    end else begin
                        $display("%h: UNKNOWN", instr);  // Unknown instruction with funct7
                    end
                end
                3'b110: begin // REMW (Remainder Word)
                    if (funct7 == 7'b0000001) begin
                        $write("%h: remw ", instr);
                        display_reg_name(rd);
                        $write(", ");
                        display_reg_name(rs1);
                        $write(", ");
                        display_reg_name(rs2);
                    end else begin
                        $display("%h: UNKNOWN", instr);  // Unknown instruction with funct7
                    end
                end
                default: $display("%h: UNKNOWN", instr);  // Unknown instruction in RV64M with opcode 0111011
            endcase
        end


        7'b0001111: begin // FENCE
            $write("%h: fence", instr);
        end

        7'b1110011: begin // ECALL
            $write("%h: ecall", instr);
        end

        default: $display("%h: UNKNOWN", instr);  // Unknown instruction
    endcase
  $display();
  end
endtask

  // Combinational decode logic
  always_comb begin
    // Default values to avoid latches
    opcode = 7'd0;
    rd = 5'd0;
    funct3 = 3'd0;
    rs1 = 5'd0;
    rs2 = 5'd0;
    imm = 12'd0;

    // Check if the FSM is in the DECODE state
    if (fsm_state == DECODE) begin
      if (instr1 != 32'b0 ) begin
        // If the read data is all-zero, terminate the simulation
        // $display("Received all-zero data, terminating simulation.");
        // terminate_simulation = 1;
        // fsm_state <= HALT;

      // display_reg_name(5'b00010);
      
        // Decode instr1
        opcode = instr1[6:0];
        rd = instr1[11:7];
        funct3 = instr1[14:12];
        rs1 = instr1[19:15];
        rs2 = instr1[24:20];
        funct7 = instr1[31:25];  // Extract the funct7 field
        imm = instr1[31:20];
        $write("%h: ", pc-8);

        // $display("PART 1 || Decoding instruction: %h", instr1);
        // $display("PART 1 || Opcode: %b, funct3: %b, rd: %b, rs1: %b, rs2: %b, imm: %d", opcode, funct3, rd, rs1, rs2, $signed(imm));
        // Call the task to decode and display instr1
        decode_and_display(instr1, opcode, rd, funct3, funct7, rs1, rs2, imm);
      end else begin
        $display("Received all-zero data, terminating simulation. || INSTR1");
        terminate_simulation = 1;
        // fsm_state <= HALT;
      end

      if (instr2 != 32'b0 ) begin
        // Decode instr2
        $write("%h: ", pc-4);
        opcode = instr2[6:0];
        rd = instr2[11:7];
        funct3 = instr2[14:12];
        rs1 = instr2[19:15];
        rs2 = instr2[24:20];
        funct7 = instr2[31:25]; 
        imm = instr2[31:20];  

        // $display("PART 2 || Decoding instruction: %h", instr2);
        // $display("PART 2 || Opcode: %b, funct3: %b, rd: %b, rs1: %b, rs2: %b, imm: %d", opcode, funct3, rd, rs1, rs2, $signed(imm));

        // Call the task to decode and display instr2
        decode_and_display(instr2, opcode, rd, funct3, funct7, rs1, rs2, imm);
      end else begin
        $display("Received all-zero data, terminating simulation. || INSTR2");
        terminate_simulation = 1;
        // fsm_state <= HALT;
      end
      $display("\n\n");
    end
  end



  // FSM control


  always_ff @(posedge clk) begin
    // $display("Always FF Block");
    // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);

    
    if (reset) begin
      // $display("Always FF Block - RESET");
      // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
      pc <= entry;
      fsm_state <= IDLE;
      m_axi_arvalid <= 0; 
      read_request_pending <= 0;
      // decode_request_pending <= 0;
      
      timeout_counter <= 0;
      // $display("Always FF Block - RESET");
      // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);

      // opcode <= 7'd0;  // Set opcode to a known default value
      // rd <= 5'd0;
      // funct3 <= 3'd0;
      // rs1 <= 5'd0;
      // rs2 <= 5'd0;
      // terminate_simulation <= 0;

    end else if (!terminate_simulation) begin
      case (fsm_state)
        IDLE: begin
          // $display("In IDLE BLOCK - Before");
          // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
          // $display("terminate_simulation: %d, m_axi_rlast: %d",terminate_simulation, m_axi_rlast);
        //  if (!read_request_pending && m_axi_arready) begin
        //       fsm_state <= FETCH;
        //   end else begin
        //       fsm_state <= IDLE;
        //   end

          fsm_state <= FETCH;
          // $display("In IDLE BLOCK - After");
          // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);

          end
    

        FETCH: begin
          // $display("In FETCH BLOCK");
          // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
          // $display("terminate_simulation: %d, m_axi_rlast: %d",terminate_simulation, m_axi_rlast);
          
          if (read_request_pending) begin
            // If a read request is already pending, do not issue a new request
            // $display("Fetch blocked: Read request already pending.");
            fsm_state <= WAIT_FOR_DATA; // Go back to WAIT_FOR_DATA to check for data availability
          end else if (m_axi_arvalid && m_axi_arready) begin 
            // $display("In FETCH BLOCK");
            // $display("m_axi_arready: %b, m_axi_arvalid: %b, fsm_state: %b", m_axi_arready, m_axi_arvalid, fsm_state);
            
            // $finish(0);
            read_request_pending <= 1;
            m_axi_arvalid <= 0;
            $finish(0);

          end else if (!m_axi_arvalid && m_axi_arready && !read_request_pending) begin
            
            // $display("In Fetch BLOCK - issue new request");
            m_axi_araddr <= pc;
            m_axi_arvalid <= 1;
            m_axi_arid <= 0;
            m_axi_arlen <= 7; 
            m_axi_arsize <= 3'b010;
            m_axi_arburst <= 2'b10;
            read_request_pending <= 1;
            // if (m_axi_rvalid) begin
            fsm_state <= WAIT_FOR_DATA;
            // pc <= pc + 8;
            // end
            
            // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
          end else begin
            $display("FETCH ERROR: m_axi_arready: %b, m_axi_arvalid: %b, fsm_state: %b", m_axi_arready, m_axi_arvalid, fsm_state);
          end
        end

        WAIT_FOR_DATA: begin
          // $display("In WAIT BLOCK");
          // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
          // $display("terminate_simulation: %d, m_axi_rlast: %d",terminate_simulation, m_axi_rlast);
          if (m_axi_arvalid) begin
            m_axi_arvalid <= 0;  // De-assert arvalid after request is accepted
          end

          if (m_axi_rvalid) begin
            // $display("In WAIT BLOCK");
            // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);

            instr1 <= m_axi_rdata[31:0];     // Lower 32 bits
            instr2 <= m_axi_rdata[63:32];    // Upper 32 bits
            m_axi_rready <= 1;  // Signal that we're ready to accept the data
            read_request_pending <= 0;
            // decode_request_pending = 0;
            timeout_counter <= 0;
            
            if (m_axi_rdata == 64'b0 ) begin
              // If the read data is all-zero, terminate the simulation
              $display("Received all-zero data, terminating simulation. || INPUT");
              terminate_simulation = 1;
              read_request_pending <= 0;
              fsm_state <= HALT;
              $finish;
            end else begin
                // $display("In WAIT BLOCK --> DECODE");
                // If not all-zero, continue with the decoding
                pc <= pc + 8; // Increment PC by 8 (fetching 64 bits)
                m_axi_arvalid <= 0;
                // decode_request_pending = 1;
                fsm_state <= DECODE;

                
          end
          
          end else begin
            timeout_counter <= timeout_counter + 1;
            if (timeout_counter > MAX_TIMEOUT) begin
              // $display("Timeout waiting for data. Moving back to IDLE.");
              fsm_state <= IDLE; 
            end else begin
              // $display("Waiting for data in WAIT State");
              fsm_state <= WAIT_FOR_DATA;
            end
          end
            
        end

        DECODE: begin
          // $display("In DECODE BLOCK");
          // $display("State: %b, arvalid: %b, arready: %b, rvalid: %b, read_request_pending: %b", fsm_state, m_axi_arvalid, m_axi_arready, m_axi_rvalid, read_request_pending);
          // $display("terminate_simulation: %d, m_axi_rlast: %d",terminate_simulation, m_axi_rlast);
          // $display("[New Instruction Received]");
          m_axi_rready <= 0;  
          // decode_request_pending = 0;
          // m_axi_arvalid <=0;
          // State control logic after decoding
          if (terminate_simulation) begin
            $display("Reached the end of Input");
            fsm_state <= HALT;
            $finish(0);
            // decode_request_pending <= 0;
          end else begin
            fsm_state <= WAIT_FOR_DATA;
          end
        end

        HALT: begin
          $display("terminate_simulation: %d, m_axi_rlast: %d",terminate_simulation, m_axi_rlast);
          $display("Simulation halted.");
          $finish; 
        end
        
      endcase
    end else if (terminate_simulation) begin
      $display("Simulation halted in Terminate!");
      // disable all; 
      fsm_state <= HALT;
      $finish;
    end
    else begin
      $display("Something is wrong with your FSM!");
    end
    end



// initial begin
//   $display("Initializing top, entry point = 0x%x", entry);
// end
endmodule